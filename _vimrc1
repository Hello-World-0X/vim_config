" let $vim="d:/tools/vim/vim/vim73/"
" let $vimrc="d:/tools/vim/vim/_vimrc"
let $ses="e:/temp/vimSession.vim"
let $session="e:/temp/vimSession.vim"
" look==========================================================================
"indent
set nocompatible
set magic
"ruler
set ruler " ru
set autoindent " ai
set sw=4
set tabstop=4 " ts
" display as more lines as possible, do not use @@
set display=lastline " dy=lastline

" ignore case while search
set ignorecase " noignorecase

set backspace=indent,eol,start
set number
set encoding=utf-8
set fencs=utf8,gbk,gb2312,cp936,gb18030
" language
language us
" set filetype when change buffer or make new file
" autocmd BufRead,BufNewFile,BufEnter,BufLeave,BufWinEnter,BufWinLeave *.* echo &ft
" autocmd BufRead,BufNewFile,BufEnter *.proto setfiletype proto
" autocmd BufRead,BufNewFile,BufEnter *.proto setfiletype protocols

set clipboard+=unnamed
" set ff=dos

" set right margin
set cc=80 " colorcolumn=80 " cc=80
" hilight current line
set cursorline
" hilight column
set cursorcolumn
let g:netrw_winsize = 20
let g:netrw_liststyle= 3 " archive 

if has("gui")
	" simalt ~x " ~x max ~n min ~r restore
	" toggle menu bar, tool bar, scroll bar
	" guioptions == go
	set guioptions-=T " += is on, -= is off
	set guioptions-=m " menu bar
	set go-=M " system menu
	set go-=R " right scroll
	set go-=r " do not show right scroll 
	set go-=L " left
	set go-=l 
	set selectmode+=mouse
endif
" set window(gui) size
if has("win32")
	set lines=25 
	set columns=100
endif

" theme
if &term == 'builtin_gui'
" do nonthing
elseif &term == 'gui'
" do nonthing
elseif &term == 'GUI'
" do nothing
elseif &term == 'win32'
" 8 colors
" 	colorscheme darkblue
elseif &term == 'xterm'
	set term=xterm-256color
" 	set term=xterm
" 	set term=win32
endif
colorscheme Monokai_Gavin
set guifont=Consolas:h13
" echo &t_Co
syntax enable
syntax on

" show white spaces
set listchars=tab:>-,trail:-
set list

" set tablabel as "number filename"
if has("gui")
	function! GuiTabLabel()
		let label = ''
		let bufnrlist = tabpagebuflist(v:lnum)

		" Add '*' if one of the buffers in the tab page is modified
		for bufnr in bufnrlist
			if getbufvar(bufnr, "&modified")
				let label = '*'
				break
			endif
		endfor
		let label = label . tabpagenr() . " " . expand("%:t")
		return label
	endfunction

	set guitablabel=%{GuiTabLabel()}
	" equivalent
" 	set guitablabel=%N\ %t
endif
" custom tabs for terminal version
function! MyTabLabel(n)
	let label = ''
	let bufnrlist = tabpagebuflist(a:n)
	" Add '*' if one of the buffers in the tab page is modified
	for bufnr in bufnrlist
		if getbufvar(bufnr, "&modified")
			let label = '*'
			break
		endif
	endfor
	" get all file names
	let winnr = tabpagewinnr(a:n)
	let fileName = bufname(bufnrlist[winnr - 1])
	let label = label . a:n . " " . fileName
	return label
endfunction

function! MyTabLine()
	let s = ''
	for i in range(tabpagenr('$'))
		" select the highlighting
		if i + 1 == tabpagenr()
			let s .= '%#TabLineSel#'
		else
			let s .= '%#TabLine#'
		endif

		" set the tab page number (for mouse clicks)
		let s .= '%' . (i + 1) . 'T'

		" the label is made by MyTabLabel()
		let s .= ' %{MyTabLabel(' . (i + 1) . ')} '
	endfor

	" after the last tab fill with TabLineFill and reset tab page nr
	let s .= '%#TabLineFill#%T'

	" right-align the label to close the current tab page
	if tabpagenr('$') > 1
		let s .= '%=%#TabLine#%999Xclose'
	endif

	return s
endfunction

set tabline=%!MyTabLine()


" other ========================================================================
" nocapatible with vi
set nocp
set nobackup
set hlsearch
set showmatch
filetype on
filetype plugin on
filetype indent on

" autocmd BufWinLeave *.ztx mkview
" autocmd BufWinEnter *.ztx silent loadview

" tags, taglist, file explorer
set tags=tags,./tags
set tags+=E:/Material/C++/SOURCE/cygwin_gcc_c++_tags
set tags+=E:/Material/C++/SOURCE/linux_systags
set autochdir
let Tlist_Show_One_File = 1
let Tlist_Exit_OnlyWindow = 1
let Tlist_Use_Right_Window = 1

"let g:winManagerWindowLayout='FileExplorer|TagList'
"nmap wm :WMToggle<cr>

" key maping ===================================================================
" tab mappings
map <M-1> 1gt
map <M-2> 2gt
map <M-3> 3gt
map <M-4> 4gt
map <M-5> 5gt
map <M-6> 6gt
map <M-7> 7gt
map <M-8> 8gt
map <M-9> 9gt
map <M-t> :tabnew<CR>
map <M-w> :tabclose<CR>
map! <M-1> <ESC>1gt
map! <M-2> <ESC>2gt
map! <M-3> <ESC>3gt
map! <M-4> <ESC>4gt
map! <M-5> <ESC>5gt
map! <M-6> <ESC>6gt
map! <M-7> <ESC>7gt
map! <M-8> <ESC>8gt
map! <M-9> <ESC>9gt
map! <M-t> <ESC>:tabnew<CR>
map! <M-w> <ESC>:tabclose<CR>
map <C-Tab> <ESC>gt
imap <C-Tab> <ESC>gt
imap <C-F4> <ESC>:tabc<CR>
map <C-F4> <ESC>:tabc<CR>
 
" Use CTRL-S for saving, also in Insert mode
noremap <C-S> :update<CR>
vnoremap <C-S> <C-C>:update<CR>
inoremap <C-S> <C-O>:update<CR>

" comment
function! Comment(commentStr)
	" echo a:commentStr
	" execute "echo " . '"' . a:commentStr . '"'
	let l:cs = ""
	if a:commentStr == "vim"
		let l:cs = '"'
	else
		let l:cs .= a:commentStr
	endif

	" comment
	" comment for codes, add commentStr at the begin of line
	exe 'map cc :s!^!' . l:cs . ' !<CR><ESC>:noh<CR>'
	exe 'vmap cc :s!^!' . l:cs . ' !<CR><ESC>:noh<CR>'
	" comment for comment, add commentStr before the first word
	exe 'map CC :s!\(^\s*\)\(.*\)!\1' . l:cs . ' \2!<CR><ESC>:noh<CR>'
	exe 'vmap CC :s!\(^\s*\)\(.*\)!\1' . l:cs . ' \2!<CR><ESC>:noh<CR>'

	" uncomment
	exe 'map cx :s!^\(\s*\)' . l:cs . ' \{0,1\}\(.*\)!\1\2!<CR><ESC>:noh<CR>'
	exe 'vmap cx :s!^\(\s*\)' . l:cs . ' \{0,1\}\(.*\)!\1\2!<CR><ESC>:noh<CR>'
	exe 'map cz :s!^\(\s*\)' . l:cs . ' \{0,1\}\(.*\)!\1\2!<CR><ESC>:noh<CR>'
	exe 'vmap cz :s!^\(\s*\)' . l:cs . ' \{0,1\}\(.*\)!\1\2!<CR><ESC>:noh<CR>'
endfunction
" comment
autocmd filetype cc,cpp,java,c,h,hpp,cxx,php,javascript call Comment('//')
autocmd filetype vim call Comment("vim")
autocmd filetype python call Comment('#')
autocmd filetype dosini call Comment(';')

function! Run()
	if &ft == "vim"
		exe 'source %'
		return ""
	endif
	for ext in ["cc", "cpp", "c", "cxx", "h", "hpp"]
		if &ft == ext
			if has("win32")
				exe '!start cmd /c start "vim run cpp" g++.lnk "%:p"'
			elseif has("unix")
				exe '!g++ -Wall "%:p";./a.out'
" 				exe '!a.out'
			endif
			return ""
		endif
	endfor
	if has("win32")
		exe '!start cmd /c start "vim run" nppCompileAndRun.lnk "%:p"'
	elseif has("unix")
" 		exe '!g++ -Wall "%:p"'
	elseif has("mac")
		" do nothing
	endif
	return ""
endfunction

map <F5> :silent call Run()<CR>
" autocmd filetype cc,cpp,c,h,hpp,cxx call RunC()
" autocmd filetype vim call RunVim()

" taglist, make tag file
function! MakeTags()
	if &ft == "cpp"
		exe '!ctags -R --langmap=.h.inl.cxx.cc --c++-kinds=+p --fields=+iaSK --extra=+q --languages=cpp'
	elseif &ft == "java"
		exe '!ctags -R --java-kinds=+p --fields=+iaS --extra=+q --languages=java'
	elseif &ft == "php"
		exe '!ctags -R --php-kinds=+cidfvj --fields=+iaSK --fields=-k --extra=+q --languages=php'
	endif
endfunction

" function! MakeCTags()
" 	map <C-F12> :!ctags -R --languagemap=.h.inl.c --c++-kinds=+p --fields=+iaS --extra=+q .<CR> " endfunction
" function! MakeJavaTags()
" 	map <C-F12> :!ctags -R --java-kinds=+p --fields=+iaS --extra=+q .<CR>
" endfunction
" autocmd filetype cc,cpp,c,h,hpp,cxx call MakeCTags()
" autocmd filetype java call MakeJavaTags()
map <C-F12> :call MakeTags()<CR>

" select all
nmap <C-A> ggVG
" redirect for ESC
imap fds <ESC>
map fds <ESC>
omap fds <ESC>
imap FDS <ESC>:echo "CAPS_LOCK!"<CR><ESC>
map FDS <ESC>:echo "CAPS_LOCK!"<CR><ESC>
omap FDS <ESC>:echo "CAPS_LOCK!"<CR><ESC>
cnoremap fds <C-U><ESC>
cnoremap FDS <C-U><ESC>:echo "CAPS_LOCK!"<CR><ESC>

" deletion, use backspace as backspace key
nmap <silent> <BS> h"zx
vmap <silent> <BS> h"zx

" open select file
vnoremap <M-g> "zy:!start cmd /c start npp_open_document.lnk "<C-R>z" "%:p" "vim"<CR>
vmap <M-g> "zy:!start cmd /c start npp_open_document.lnk "<C-R>z" "%:p" "vim"<CR>

" using * and # search for selected content
vnoremap <silent> * :<C-U>
	\let old_reg=getreg('"')<Bar>let old_regtype=getregtype('"')<CR>
	\gvy/<C-R><C-R>=substitute(
		\escape(@", '/\.*$^~['), '\_s\+', '\\_s\\+', 'g')<CR><CR>
	\gV:call setreg('"', old_reg, old_regtype)<CR>
vnoremap <silent> # :<C-U>
	\let old_reg=getreg('"')<Bar>let old_regtype=getregtype('"')<CR>
	\gvy?<C-R><C-R>=substitute(
		\escape(@", '?\.*$^~['), '\_s\+', '\\_s\\+', 'g')<CR><CR>
	\gV:call setreg('"', old_reg, old_regtype)<CR>

" adjust the window size
" :resize n or :vertical resize n, where n is the size in height/width
" horizontal size, height
nmap <M-]> :resize +1<CR>
nmap <M-[> :resize -1<CR>
" vertical size, width
nmap <M-=> :vertical resize +1<CR>
nmap <M--> :vertical resize -1<CR>
" maximize window
nmap <F11> :simalt ~x<CR>

" append ";" at the end of line, for cpp,php,js
" imap ;; <ESC>A;
" nmap ;; <ESC>A;<ESC>

" auto complete
imap <C-space> <C-x><C-o><C-p>
autocmd filetype set dictionary-=E:/Material/Linux/Vim/config/php_function_list.txt
" OmniCppComplete
" let g:OmniCpp_NamespaceSearch = 1
" let g:OmniCpp_GlobalScopeSearch = 1
" let g:OmniCpp_ShowAccess = 1
let g:OmniCpp_ShowPrototypeInAbbr = 1 " show function parameters
" let g:OmniCpp_MayCompleteDot = 1 " autocomplete after .
" let g:OmniCpp_MayCompleteArrow = 1 " autocomplete after ->
" let g:OmniCpp_MayCompleteScope = 1 " autocomplete after ::
let g:OmniCpp_DefaultNamespaces = ["std", "_GLIBCXX_STD", "__gnu_std"]
let g:OmniCpp_SelectFirstItem = 2 " select first popup item (without inserting it to the text)
" automatically open and close the popup menu / preview window
" au CursorMovedI,InsertLeave * if pumvisible() == 0|silent! pclose|endif
" set completeopt=menuone,menu,longest,preview
set completeopt=menuone,menu
au BufNewFile,BufRead,BufEnter *.cpp,*.hpp set omnifunc=omni#cpp#complete#Main


" nohlsearch
noh 


